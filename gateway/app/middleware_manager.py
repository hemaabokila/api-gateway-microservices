import logging
from typing import Optional, List, Protocol, runtime_checkable
from flask import Response, Request
from http import HTTPStatus

logger = logging.getLogger(__name__)

@runtime_checkable
class Middleware(Protocol):
    """
    Protocol defining the interface for middleware objects for Flask.
    Any class implementing these methods can be considered a Middleware.
    """
    def process_request(self, request: Request) -> Optional[Response]:
        """
        Process an incoming request before the view is dispatched.
        Can modify the request or return a Flask Response to short-circuit the request processing chain.
        """
        pass

    def process_response(self, request: Request, response: Response) -> Response:
        """
        Process the outgoing Flask response after the view has been executed.
        Can modify the response. This method is called in reverse order of middleware addition.
        """
        pass

class MiddlewareManager:
    """
    Manages a list of middleware instances and applies them to requests and responses.
    Middlewares are processed in the order they are added for process_request
    and in reverse order for process_response.
    """
    def __init__(self):
        self.middlewares: List[Middleware] = []
        logger.info("MiddlewareManager initialized.")

    def add_middleware(self, middleware: Middleware):
        middleware_name = getattr(middleware, '__class__', type(middleware)).__name__
        logger.debug(f"Attempting to add middleware: {middleware_name}")

        if not isinstance(middleware, Middleware):
            logger.error(f"Attempted to add object that does not implement Middleware Protocol: {middleware_name}")
            raise TypeError("Middleware object must implement the Middleware Protocol (have callable 'process_request' and 'process_response' methods).")

        self.middlewares.append(middleware)
        logger.info(f"Middleware added successfully: {middleware_name}. Total middlewares: {len(self.middlewares)}")

    def process_request(self, request: Request) -> Optional[Response]:
        """
        Applies the process_request method of each middleware in the order they were added.
        Stops the chain and returns a Flask Response object if any middleware returns one.
        Exceptions raised by middlewares are caught and result in a 500 Internal Server Error response.
        """
        logger.debug(f"MiddlewareManager: Starting request middleware chain for {request.method} {request.path}.")

        final_response = None

        for middleware in self.middlewares:
            middleware_name = getattr(middleware, '__class__', type(middleware)).__name__
            logger.debug(f"MiddlewareManager: Processing request with {middleware_name}")

            try:
                response = middleware.process_request(request)

                if response is not None:
                    logger.info(f"Request short-circuited by middleware: {middleware_name} (Status: {getattr(response, 'status_code', 'N/A')})")
                    if not isinstance(response, Response):
                        logger.error(f"Middleware {middleware_name} returned unexpected type {type(response)} in process_request for {request.method} {request.path}. Expected Flask Response. Returning 500.")
                        final_response = Response("Internal Server Error: Invalid middleware response type.", status=HTTPStatus.INTERNAL_SERVER_ERROR.value, mimetype='text/plain')
                    else:
                        final_response = response
                    break

            except Exception as e:
                logger.exception(f"Error in process_request of {middleware_name} for {request.method} {request.path}: {e}")
                final_response = Response("Internal Server Error: Middleware processing failed.", status=HTTPStatus.INTERNAL_SERVER_ERROR.value, mimetype='text/plain')
                break

        if final_response is None:
            logger.debug("MiddlewareManager: Request passed through all request middlewares without short-circuit. Proceeding to view.")

        return final_response

    def process_response(self, request: Request, response: Response) -> Response:
        """
        Applies the process_response method of each middleware in reverse order of addition.
        Starts with the response generated by the view or a short-circuiting middleware.
        Each middleware receives the output of the previous one.
        Exceptions raised by middlewares are caught and logged, but the response chain attempts to continue.
        """
        logger.debug(f"MiddlewareManager: Starting response middleware chain for {request.method} {request.path}.")

        processed_response = response

        for middleware in reversed(self.middlewares):
            middleware_name = getattr(middleware, '__class__', type(middleware)).__name__
            logger.debug(f"MiddlewareManager: Processing response with {middleware_name}")

            try:
                middleware_response = middleware.process_response(request, processed_response)

                if not isinstance(middleware_response, Response):
                    logger.error(f"Response Middleware {middleware_name} returned unexpected type {type(middleware_response)} in process_response for {request.method} {request.path}. Expected Flask Response. Attempting to continue with previous response.")
                else:
                    processed_response = middleware_response

            except Exception as e:
                logger.exception(f"Error in process_response of {middleware_name} for {request.method} {request.path}: {e}")

        logger.debug(f"MiddlewareManager: Response passed through all response middlewares. Finalizing response for {request.method} {request.path}.")
        return processed_response

